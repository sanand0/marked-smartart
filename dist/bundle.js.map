{
  "version": 3,
  "sources": ["../node_modules/@webcontainer/api/dist/internal/constants.js", "../node_modules/@webcontainer/api/dist/internal/TypedEventTarget.js", "../node_modules/@webcontainer/api/dist/internal/tokens.js", "../node_modules/@webcontainer/api/dist/internal/iframe-url.js", "../node_modules/@webcontainer/api/dist/internal/reset-promise.js", "../node_modules/@webcontainer/api/dist/internal/auth-state.js", "../node_modules/@webcontainer/api/dist/preview-message-types.js", "../node_modules/@webcontainer/api/dist/vendor/index.js", "../node_modules/@webcontainer/api/dist/utils/is-preview-message.js", "../node_modules/@webcontainer/api/dist/utils/null-prototype.js", "../node_modules/@webcontainer/api/dist/utils/file-system.js", "../node_modules/@webcontainer/api/dist/index.js", "../script.js"],
  "sourcesContent": ["export const DEFAULT_EDITOR_ORIGIN = 'https://stackblitz.com';\nexport const SEARCH_PARAM_AUTH_CODE = 'code';\nexport const SEARCH_PARAM_ERROR = 'error';\nexport const SEARCH_PARAM_ERROR_DESCRIPTION = 'error_description';\nexport const BROADCAST_CHANNEL_NAME = '__wc_api_bc__';\nexport const STORAGE_TOKENS_NAME = '__wc_api_tokens__';\nexport const STORAGE_CODE_VERIFIER_NAME = '__wc_api_verifier__';\nexport const STORAGE_POPUP_NAME = '__wc_api_popup__';\n", "export class TypedEventTarget {\n    _bus = new EventTarget();\n    listen(listener) {\n        function wrappedListener(event) {\n            listener(event.data);\n        }\n        this._bus.addEventListener('message', wrappedListener);\n        return () => this._bus.removeEventListener('message', wrappedListener);\n    }\n    fireEvent(data) {\n        this._bus.dispatchEvent(new MessageEvent('message', { data }));\n    }\n}\n", "import { STORAGE_TOKENS_NAME } from './constants.js';\nimport { TypedEventTarget } from './TypedEventTarget.js';\nconst IGNORED_ERROR = new Error();\nIGNORED_ERROR.stack = '';\nconst accessTokenChangedListeners = new TypedEventTarget();\n/**\n * @internal\n */\nexport class Tokens {\n    origin;\n    refresh;\n    access;\n    expires;\n    _revoked = new AbortController();\n    constructor(\n    // editor origin that those tokens are bound to, mostly used for development\n    origin, \n    // token to use to get a new access token\n    refresh, \n    // token to provide to webcontainer\n    access, \n    // time in UTC when the token expires\n    expires) {\n        this.origin = origin;\n        this.refresh = refresh;\n        this.access = access;\n        this.expires = expires;\n    }\n    async activate(onFailedRefresh) {\n        if (this._revoked.signal.aborted) {\n            throw new Error('Token revoked');\n        }\n        // if the access token expired we fetch a new one\n        if (this.expires < Date.now()) {\n            if (!(await this._fetchNewAccessToken())) {\n                return false;\n            }\n        }\n        this._sync();\n        this._startRefreshTokensLoop(onFailedRefresh);\n        return true;\n    }\n    async revoke(clientId, ignoreRevokeError) {\n        this._revoked.abort();\n        try {\n            const response = await fetch(`${this.origin}/oauth/revoke`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: new URLSearchParams({ token: this.refresh, token_type_hint: 'refresh_token', client_id: clientId }),\n                mode: 'cors',\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to logout`);\n            }\n        }\n        catch (error) {\n            if (!ignoreRevokeError) {\n                throw error;\n            }\n        }\n        clearTokensInStorage();\n    }\n    static fromStorage() {\n        const savedTokens = readTokensFromStorage();\n        if (!savedTokens) {\n            return null;\n        }\n        return new Tokens(savedTokens.origin, savedTokens.refresh, savedTokens.access, savedTokens.expires);\n    }\n    static async fromAuthCode({ editorOrigin, clientId, codeVerifier, authCode, redirectUri, }) {\n        const response = await fetch(`${editorOrigin}/oauth/token`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            body: new URLSearchParams({\n                client_id: clientId,\n                code: authCode,\n                code_verifier: codeVerifier,\n                grant_type: 'authorization_code',\n                redirect_uri: redirectUri,\n            }),\n            mode: 'cors',\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch token: ${response.status}`);\n        }\n        const tokenResponse = await response.json();\n        assertTokenResponse(tokenResponse);\n        const { access_token: access, refresh_token: refresh } = tokenResponse;\n        const expires = getExpiresFromTokenResponse(tokenResponse);\n        return new Tokens(editorOrigin, refresh, access, expires);\n    }\n    async _fetchNewAccessToken() {\n        try {\n            const response = await fetch(`${this.origin}/oauth/token`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: new URLSearchParams({\n                    grant_type: 'refresh_token',\n                    refresh_token: this.refresh,\n                }),\n                mode: 'cors',\n                signal: this._revoked.signal,\n            });\n            if (!response.ok) {\n                throw IGNORED_ERROR;\n            }\n            const tokenResponse = await response.json();\n            assertTokenResponse(tokenResponse);\n            const { access_token: access, refresh_token: refresh } = tokenResponse;\n            const expires = getExpiresFromTokenResponse(tokenResponse);\n            this.access = access;\n            this.expires = expires;\n            this.refresh = refresh;\n            return true;\n        }\n        catch {\n            clearTokensInStorage();\n            return false;\n        }\n    }\n    _sync() {\n        persistTokensInStorage(this);\n        fireAccessTokenChanged(this.access);\n    }\n    async _startRefreshTokensLoop(onFailedRefresh) {\n        while (true) {\n            const expiresIn = this.expires - Date.now() - 1000;\n            await wait(Math.max(expiresIn, 1000));\n            if (this._revoked.signal.aborted) {\n                return;\n            }\n            if (!this._fetchNewAccessToken()) {\n                onFailedRefresh();\n                return;\n            }\n            this._sync();\n        }\n    }\n}\n/**\n * @internal\n */\nexport function clearTokensInStorage() {\n    localStorage.removeItem(STORAGE_TOKENS_NAME);\n}\n/**\n * @internal\n */\nexport function addAccessTokenChangedListener(listener) {\n    return accessTokenChangedListeners.listen(listener);\n}\nfunction readTokensFromStorage() {\n    const serializedTokens = localStorage.getItem(STORAGE_TOKENS_NAME);\n    if (!serializedTokens) {\n        return null;\n    }\n    try {\n        return JSON.parse(serializedTokens);\n    }\n    catch {\n        return null;\n    }\n}\nfunction persistTokensInStorage(tokens) {\n    localStorage.setItem(STORAGE_TOKENS_NAME, JSON.stringify(tokens));\n}\nfunction getExpiresFromTokenResponse({ created_at, expires_in }) {\n    return (created_at + expires_in) * 1000;\n}\nfunction assertTokenResponse(token) {\n    if (typeof token !== 'object' || !token) {\n        throw new Error('Invalid Token Response');\n    }\n    if (typeof token.access_token !== 'string' ||\n        typeof token.refresh_token !== 'string' ||\n        typeof token.created_at !== 'number' ||\n        typeof token.expires_in !== 'number') {\n        throw new Error('Invalid Token Response');\n    }\n}\nfunction wait(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction fireAccessTokenChanged(accessToken) {\n    accessTokenChangedListeners.fireEvent(accessToken);\n}\n", "import { DEFAULT_EDITOR_ORIGIN } from './constants.js';\nconst params = {};\nlet editorOrigin = null;\nexport const iframeSettings = {\n    get editorOrigin() {\n        if (editorOrigin == null) {\n            editorOrigin = new URL(globalThis.WEBCONTAINER_API_IFRAME_URL ?? DEFAULT_EDITOR_ORIGIN).origin;\n        }\n        return editorOrigin;\n    },\n    set editorOrigin(newOrigin) {\n        editorOrigin = new URL(newOrigin).origin;\n    },\n    setQueryParam(key, value) {\n        params[key] = value;\n    },\n    get url() {\n        const url = new URL(this.editorOrigin);\n        url.pathname = '/headless';\n        for (const param in params) {\n            url.searchParams.set(param, params[param]);\n        }\n        url.searchParams.set('version', \"1.5.3\");\n        return url;\n    },\n};\n", "/**\n * @internal\n */\nexport function resettablePromise() {\n    let resolve;\n    let promise;\n    function reset() {\n        promise = new Promise((_resolve) => (resolve = _resolve));\n    }\n    reset();\n    return {\n        get promise() {\n            return promise;\n        },\n        resolve(value) {\n            return resolve(value);\n        },\n        reset,\n    };\n}\n", "import { Tokens, clearTokensInStorage } from './tokens.js';\nimport { SEARCH_PARAM_AUTH_CODE, SEARCH_PARAM_ERROR, STORAGE_CODE_VERIFIER_NAME, BROADCAST_CHANNEL_NAME, STORAGE_POPUP_NAME, SEARCH_PARAM_ERROR_DESCRIPTION, } from './constants.js';\nimport { iframeSettings } from './iframe-url.js';\nimport { S256, newCodeVerifier } from './code.js';\nimport { resettablePromise } from './reset-promise.js';\nimport { TypedEventTarget } from './TypedEventTarget.js';\n/**\n * @internal\n */\nexport const authState = {\n    initialized: false,\n    bootCalled: false,\n    authComplete: resettablePromise(),\n    clientId: '',\n    oauthScope: '',\n    broadcastChannel: null,\n    get editorOrigin() {\n        return iframeSettings.editorOrigin;\n    },\n    tokens: null,\n};\nconst authFailedListeners = new TypedEventTarget();\nconst loggedOutListeners = new TypedEventTarget();\nfunction broadcastMessage(message) {\n    if (!authState.broadcastChannel) {\n        return;\n    }\n    authState.broadcastChannel.postMessage(message);\n    // check if we are in a popup mode\n    if (localStorage.getItem(STORAGE_POPUP_NAME) === 'true' && message.type !== 'auth-logout') {\n        localStorage.removeItem(STORAGE_POPUP_NAME);\n        // wait a tick to make sure the posted message has been sent\n        setTimeout(() => {\n            window.close();\n        });\n    }\n}\nexport const auth = {\n    init({ editorOrigin, clientId, scope }) {\n        if (authState.initialized) {\n            throw new Error('Init should only be called once');\n        }\n        let enterprise = true;\n        if (enterprise && authState.bootCalled) {\n            throw new Error('`auth.init` should always be called before `WebContainer.boot`');\n        }\n        authState.initialized = true;\n        authState.tokens = Tokens.fromStorage();\n        authState.clientId = clientId;\n        authState.oauthScope = scope;\n        authState.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n        // configure iframe url\n        iframeSettings.setQueryParam('client_id', clientId);\n        if (editorOrigin) {\n            iframeSettings.editorOrigin = new URL(editorOrigin).origin;\n        }\n        loggedOutListeners.listen(() => authState.authComplete.reset());\n        // if authentication or logout are done in another page, we want to reflect the state on this page as well\n        authState.broadcastChannel.addEventListener('message', onChannelMessage);\n        async function onChannelMessage(event) {\n            const typedEvent = event.data;\n            if (typedEvent.type === 'auth-complete') {\n                authState.tokens = Tokens.fromStorage();\n                // we ignore the possible error here because they can't have expired just yet\n                await authState.tokens.activate(onFailedTokenRefresh);\n                authState.authComplete.resolve();\n                return;\n            }\n            if (typedEvent.type === 'auth-failed') {\n                authFailedListeners.fireEvent(typedEvent);\n                return;\n            }\n            if (typedEvent.type === 'auth-logout') {\n                loggedOutListeners.fireEvent();\n                return;\n            }\n        }\n        if (authState.tokens) {\n            const tokens = authState.tokens;\n            if (tokens.origin === authState.editorOrigin) {\n                /**\n                 * Here we assume that the refresh token never expires which\n                 * might not be correct. If that is the case though, we will\n                 * emit a 'logged-out' event to signal that the user has been\n                 * logged out, which could also happen at a later time anyway.\n                 *\n                 * Because this flow is done entirely locally, we do not broadcast\n                 * anything to the other tabs. They should be performing a similar\n                 * check.\n                 */\n                (async () => {\n                    const success = await tokens.activate(onFailedTokenRefresh);\n                    if (!success) {\n                        // if we got new token in the meantime we discard this error\n                        if (authState.tokens !== tokens) {\n                            return;\n                        }\n                        loggedOutListeners.fireEvent();\n                        return;\n                    }\n                    authState.authComplete.resolve();\n                })();\n                return { status: 'authorized' };\n            }\n            clearTokensInStorage();\n            authState.tokens = null;\n        }\n        const locationURL = new URL(window.location.href);\n        const { searchParams } = locationURL;\n        const updateURL = () => window.history.replaceState({}, document.title, locationURL);\n        // check for errors first, aka the user declined the authorisation or stackblitz did\n        if (searchParams.has(SEARCH_PARAM_ERROR)) {\n            const error = searchParams.get(SEARCH_PARAM_ERROR);\n            const description = searchParams.get(SEARCH_PARAM_ERROR_DESCRIPTION);\n            searchParams.delete(SEARCH_PARAM_ERROR);\n            searchParams.delete(SEARCH_PARAM_ERROR_DESCRIPTION);\n            updateURL();\n            broadcastMessage({ type: 'auth-failed', error, description });\n            return { status: 'auth-failed', error, description };\n        }\n        // if there's an auth code\n        if (searchParams.has(SEARCH_PARAM_AUTH_CODE)) {\n            const authCode = searchParams.get(SEARCH_PARAM_AUTH_CODE);\n            const editorOrigin = authState.editorOrigin;\n            searchParams.delete(SEARCH_PARAM_AUTH_CODE);\n            updateURL();\n            const codeVerifier = localStorage.getItem(STORAGE_CODE_VERIFIER_NAME);\n            if (!codeVerifier) {\n                return { status: 'need-auth' };\n            }\n            localStorage.removeItem(STORAGE_CODE_VERIFIER_NAME);\n            Tokens.fromAuthCode({\n                editorOrigin,\n                clientId: authState.clientId,\n                authCode,\n                codeVerifier,\n                redirectUri: defaultRedirectUri(),\n            })\n                .then(async (tokens) => {\n                authState.tokens = tokens;\n                assertAuthTokens(authState.tokens);\n                const success = await authState.tokens.activate(onFailedTokenRefresh);\n                // if authentication failed we throw, and we'll mark auth as failed\n                if (!success) {\n                    throw new Error();\n                }\n                authState.authComplete.resolve();\n                broadcastMessage({ type: 'auth-complete' });\n            })\n                .catch((error) => {\n                // this should never happen unless the rails app is now down for some reason?\n                console.error(error);\n                // treat it as a logged out event so that the user can retry to login\n                loggedOutListeners.fireEvent();\n                broadcastMessage({ type: 'auth-logout' });\n            });\n            return { status: 'authorized' };\n        }\n        return { status: 'need-auth' };\n    },\n    async startAuthFlow({ popup } = {}) {\n        if (!authState.initialized) {\n            throw new Error('auth.init must be called first');\n        }\n        if (popup) {\n            localStorage.setItem(STORAGE_POPUP_NAME, 'true');\n            const height = 500;\n            const width = 620;\n            const left = window.screenLeft + (window.outerWidth - width) / 2;\n            const top = window.screenTop + (window.outerHeight - height) / 2;\n            window.open(await generateOAuthRequest(), '_blank', `popup,width=${width},height=${height},left=${left},top=${top}`);\n        }\n        else {\n            window.location.href = await generateOAuthRequest();\n        }\n    },\n    async logout({ ignoreRevokeError } = {}) {\n        await authState.tokens?.revoke(authState.clientId, ignoreRevokeError ?? false);\n        loggedOutListeners.fireEvent();\n        broadcastMessage({ type: 'auth-logout' });\n    },\n    loggedIn() {\n        return authState.authComplete.promise;\n    },\n    on(event, listener) {\n        switch (event) {\n            case 'auth-failed': {\n                return authFailedListeners.listen(listener);\n            }\n            case 'logged-out': {\n                return loggedOutListeners.listen(listener);\n            }\n            default: {\n                throw new Error(`Unsupported event type '${event}'.`);\n            }\n        }\n    },\n};\nfunction onFailedTokenRefresh() {\n    loggedOutListeners.fireEvent();\n    broadcastMessage({ type: 'auth-logout' });\n}\nfunction defaultRedirectUri() {\n    return window.location.href;\n}\nasync function generateOAuthRequest() {\n    const codeVerifier = newCodeVerifier();\n    localStorage.setItem(STORAGE_CODE_VERIFIER_NAME, codeVerifier);\n    const codeChallenge = await S256(codeVerifier);\n    const url = new URL('/oauth/authorize', authState.editorOrigin);\n    const { searchParams } = url;\n    searchParams.append('response_type', 'code');\n    searchParams.append('client_id', authState.clientId);\n    searchParams.append('redirect_uri', defaultRedirectUri());\n    searchParams.append('scope', authState.oauthScope);\n    searchParams.append('code_challenge', codeChallenge);\n    searchParams.append('code_challenge_method', 'S256');\n    return url.toString();\n}\n/**\n * @internal\n */\nexport function assertAuthTokens(tokens) {\n    if (!tokens) {\n        throw new Error('Oops! Tokens is not defined when it always should be.');\n    }\n}\n", "/**\n * This type is in a separate module so that localservice can import it\n * without bundling all the other webcontainer specific stuff.\n */\nexport var PreviewMessageType;\n(function (PreviewMessageType) {\n    PreviewMessageType[\"UncaughtException\"] = \"PREVIEW_UNCAUGHT_EXCEPTION\";\n    PreviewMessageType[\"UnhandledRejection\"] = \"PREVIEW_UNHANDLED_REJECTION\";\n    PreviewMessageType[\"ConsoleError\"] = \"PREVIEW_CONSOLE_ERROR\";\n})(PreviewMessageType || (PreviewMessageType = {}));\n", "var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// dist/vendor/comlink.js\nvar comlink_exports = {};\n__export(comlink_exports, {\n  createEndpoint: () => createEndpoint,\n  expose: () => expose,\n  proxy: () => proxy,\n  proxyMarker: () => proxyMarker,\n  releaseProxy: () => releaseProxy,\n  transfer: () => transfer,\n  transferHandlers: () => transferHandlers,\n  windowEndpoint: () => windowEndpoint,\n  wrap: () => wrap\n});\n\n// ../../node_modules/comlink/dist/esm/comlink.mjs\nvar proxyMarker = Symbol(\"Comlink.proxy\");\nvar createEndpoint = Symbol(\"Comlink.endpoint\");\nvar releaseProxy = Symbol(\"Comlink.releaseProxy\");\nvar throwMarker = Symbol(\"Comlink.thrown\");\nvar isObject = (val) => typeof val === \"object\" && val !== null || typeof val === \"function\";\nvar proxyTransferHandler = {\n  canHandle: (val) => isObject(val) && val[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  }\n};\nvar throwTransferHandler = {\n  canHandle: (value) => isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack\n        }\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(new Error(serialized.value.message), serialized.value);\n    }\n    throw serialized.value;\n  }\n};\nvar transferHandlers = /* @__PURE__ */ new Map([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler]\n]);\nfunction expose(obj, ep = self) {\n  ep.addEventListener(\"message\", function callback(ev) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = Object.assign({ path: [] }, ev.data);\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);\n      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);\n      switch (type) {\n        case 0:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case 1:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case 2:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case 3:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case 4:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case 5:\n          {\n            returnValue = void 0;\n          }\n          break;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue).catch((value) => {\n      return { value, [throwMarker]: 0 };\n    }).then((returnValue2) => {\n      const [wireValue, transferables] = toWireValue(returnValue2);\n      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n      if (type === 5) {\n        ep.removeEventListener(\"message\", callback);\n        closeEndPoint(ep);\n      }\n    });\n  });\n  if (ep.start) {\n    ep.start();\n  }\n}\nfunction isMessagePort(endpoint) {\n  return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n  if (isMessagePort(endpoint))\n    endpoint.close();\n}\nfunction wrap(ep, target) {\n  return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\nfunction createProxy(ep, path = [], target = function() {\n}) {\n  let isProxyReleased = false;\n  const proxy2 = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: 5,\n            path: path.map((p) => p.toString())\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy2 };\n        }\n        const r = requestResponseMessage(ep, {\n          type: 0,\n          path: path.map((p) => p.toString())\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(ep, {\n        type: 1,\n        path: [...path, prop].map((p) => p.toString()),\n        value\n      }, transferables).then(fromWireValue);\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if (last === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: 4\n        }).then(fromWireValue);\n      }\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(ep, {\n        type: 2,\n        path: path.map((p) => p.toString()),\n        argumentList\n      }, transferables).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(ep, {\n        type: 3,\n        path: path.map((p) => p.toString()),\n        argumentList\n      }, transferables).then(fromWireValue);\n    }\n  });\n  return proxy2;\n}\nfunction myFlat(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nvar transferCache = /* @__PURE__ */ new WeakMap();\nfunction transfer(obj, transfers) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\nfunction proxy(obj) {\n  return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\n  return {\n    postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context)\n  };\n}\nfunction toWireValue(value) {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: 3,\n          name,\n          value: serializedValue\n        },\n        transferables\n      ];\n    }\n  }\n  return [\n    {\n      type: 0,\n      value\n    },\n    transferCache.get(value) || []\n  ];\n}\nfunction fromWireValue(value) {\n  switch (value.type) {\n    case 3:\n      return transferHandlers.get(value.name).deserialize(value.value);\n    case 0:\n      return value.value;\n  }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l);\n      resolve(ev.data);\n    });\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage(Object.assign({ id }, msg), transfers);\n  });\n}\nfunction generateUUID() {\n  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\nexport {\n  comlink_exports as Comlink\n};\n", "import { PreviewMessageType } from '../preview-message-types.js';\nconst PREVIEW_MESSAGE_TYPES = [\n    PreviewMessageType.ConsoleError,\n    PreviewMessageType.UncaughtException,\n    PreviewMessageType.UnhandledRejection,\n];\nexport function isPreviewMessage(data) {\n    if (data == null || typeof data !== 'object') {\n        return false;\n    }\n    if (!('type' in data) || !PREVIEW_MESSAGE_TYPES.includes(data.type)) {\n        return false;\n    }\n    return true;\n}\n", "/**\n * @internal\n */\nexport function nullPrototype(source) {\n    const prototype = Object.create(null);\n    if (!source) {\n        return prototype;\n    }\n    return Object.assign(prototype, source);\n}\n", "import { nullPrototype } from './null-prototype.js';\nconst binaryDecoder = new TextDecoder('latin1');\n/**\n * @internal\n */\nexport function toInternalFileSystemTree(tree) {\n    const newTree = { d: {} };\n    for (const name of Object.keys(tree)) {\n        const entry = tree[name];\n        if ('file' in entry) {\n            if ('symlink' in entry.file) {\n                newTree.d[name] = { f: { l: entry.file.symlink } };\n                continue;\n            }\n            const contents = entry.file.contents;\n            const stringContents = typeof contents === 'string' ? contents : binaryDecoder.decode(contents);\n            const binary = typeof contents === 'string' ? {} : { b: true };\n            newTree.d[name] = { f: { c: stringContents, ...binary } };\n            continue;\n        }\n        const newEntry = toInternalFileSystemTree(entry.directory);\n        newTree.d[name] = newEntry;\n    }\n    return newTree;\n}\n/**\n * @internal\n */\nexport function toExternalFileSystemTree(tree) {\n    const newTree = nullPrototype();\n    if ('f' in tree) {\n        throw new Error('It is not possible to export a single file in the JSON format.');\n    }\n    if ('d' in tree) {\n        for (const name of Object.keys(tree.d)) {\n            const entry = tree.d[name];\n            if ('d' in entry) {\n                newTree[name] = nullPrototype({\n                    directory: toExternalFileSystemTree(entry),\n                });\n            }\n            else if ('f' in entry) {\n                if ('c' in entry.f) {\n                    newTree[name] = nullPrototype({\n                        file: nullPrototype({\n                            contents: entry.f.b ? fromBinaryString(entry.f.c) : entry.f.c,\n                        }),\n                    });\n                }\n                else if ('l' in entry.f) {\n                    newTree[name] = nullPrototype({\n                        file: nullPrototype({\n                            symlink: entry.f.l,\n                        }),\n                    });\n                }\n            }\n        }\n    }\n    return newTree;\n}\nfunction fromBinaryString(s) {\n    const encoded = new Uint8Array(s.length);\n    for (let i = 0; i < s.length; i++) {\n        encoded[i] = s[i].charCodeAt(0);\n    }\n    return encoded;\n}\n", "/**\n * The WebContainer Public API allows you build custom applications on top of an in-browser Node.js runtime.\n *\n * Its main entrypoint is the {@link WebContainer} class.\n *\n * @packageDocumentation\n */\nimport { authState, assertAuthTokens } from './internal/auth-state.js';\nimport { PreviewMessageType } from './preview-message-types.js';\nimport { Comlink } from './vendor/index.js';\nimport { auth as authImpl } from './internal/auth-state.js';\nimport { addAccessTokenChangedListener } from './internal/tokens.js';\nimport { iframeSettings } from './internal/iframe-url.js';\nimport { isPreviewMessage } from './utils.js';\nimport { toExternalFileSystemTree, toInternalFileSystemTree } from './utils/file-system.js';\nexport const auth = authImpl;\nexport { PreviewMessageType };\nexport * from './utils.js';\nlet bootPromise = null;\nlet cachedServerPromise = null;\nlet cachedBootOptions = {};\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\n/**\n * The main export of this library. An instance of `WebContainer` represents a runtime\n * ready to be used.\n */\nexport class WebContainer {\n    _instance;\n    _runtimeInfo;\n    /**\n     * Gives access to the underlying file system.\n     */\n    fs;\n    static _instance = null;\n    _tornDown = false;\n    _unsubscribeFromTokenChangedListener = () => { };\n    /** @internal */\n    constructor(\n    /** @internal */\n    _instance, fs, previewScript, \n    /** @internal */\n    _runtimeInfo) {\n        this._instance = _instance;\n        this._runtimeInfo = _runtimeInfo;\n        this.fs = new FileSystemAPIClient(fs);\n        // forward the credentials to webcontainer if needed\n        if (authState.initialized) {\n            this._unsubscribeFromTokenChangedListener = addAccessTokenChangedListener((accessToken) => {\n                this._instance.setCredentials({ accessToken, editorOrigin: authState.editorOrigin });\n            });\n            (async () => {\n                await authState.authComplete.promise;\n                if (this._tornDown) {\n                    return;\n                }\n                assertAuthTokens(authState.tokens);\n                await this._instance.setCredentials({\n                    accessToken: authState.tokens.access,\n                    editorOrigin: authState.editorOrigin,\n                });\n            })().catch((error) => {\n                // print the error as this is likely a bug in webcontainer\n                console.error(error);\n            });\n        }\n    }\n    async spawn(command, optionsOrArgs, options) {\n        let args = [];\n        if (Array.isArray(optionsOrArgs)) {\n            args = optionsOrArgs;\n        }\n        else {\n            options = optionsOrArgs;\n        }\n        let output = undefined;\n        let outputStream = new ReadableStream();\n        if (options?.output !== false) {\n            const result = streamWithPush();\n            output = result.push;\n            outputStream = result.stream;\n        }\n        let stdout = undefined;\n        let stdoutStream;\n        let stderr = undefined;\n        let stderrStream;\n        const wrappedOutput = proxyListener(binaryListener(output));\n        const wrappedStdout = proxyListener(binaryListener(stdout));\n        const wrappedStderr = proxyListener(binaryListener(stderr));\n        const process = await this._instance.run({\n            command,\n            args,\n            cwd: options?.cwd,\n            env: options?.env,\n            terminal: options?.terminal,\n        }, wrappedStdout, wrappedStderr, wrappedOutput);\n        return new WebContainerProcessImpl(process, outputStream, stdoutStream, stderrStream);\n    }\n    async export(path, options) {\n        const serializeOptions = {\n            format: options?.format ?? 'json',\n            includes: options?.includes,\n            excludes: options?.excludes,\n            external: true,\n        };\n        const result = await this._instance.serialize(path, serializeOptions);\n        if (serializeOptions.format === 'json') {\n            const data = JSON.parse(decoder.decode(result));\n            return toExternalFileSystemTree(data);\n        }\n        return result;\n    }\n    on(event, listener) {\n        if (event === 'preview-message') {\n            const originalListener = listener;\n            listener = ((message) => {\n                if (isPreviewMessage(message)) {\n                    originalListener(message);\n                }\n            });\n        }\n        const { listener: wrapped, subscribe } = syncSubscription(listener);\n        return subscribe(this._instance.on(event, Comlink.proxy(wrapped)));\n    }\n    /**\n     * Mounts a tree of files into the filesystem. This can be specified as a tree object ({@link FileSystemTree})\n     * or as a binary snapshot generated by [`@webcontainer/snapshot`](https://www.npmjs.com/package/@webcontainer/snapshot).\n     *\n     * @param snapshotOrTree - A tree of files, or a binary snapshot. Note that binary payloads will be transferred.\n     * @param options.mountPoint - Specifies a nested path where the tree should be mounted.\n     */\n    mount(snapshotOrTree, options) {\n        const payload = snapshotOrTree instanceof Uint8Array\n            ? snapshotOrTree\n            : snapshotOrTree instanceof ArrayBuffer\n                ? new Uint8Array(snapshotOrTree)\n                : encoder.encode(JSON.stringify(toInternalFileSystemTree(snapshotOrTree)));\n        return this._instance.loadFiles(Comlink.transfer(payload, [payload.buffer]), {\n            mountPoints: options?.mountPoint,\n        });\n    }\n    /**\n     * Set a custom script to be injected into all previews. When this function is called, every\n     * future page reload will contain the provided script tag on all HTML responses.\n     *\n     * Note:\n     *\n     * When this function resolves, every preview reloaded _after_ will have the new script.\n     * Existing preview have to be explicitely reloaded.\n     *\n     * To reload a preview you can use `reloadPreview`.\n     *\n     * @param scriptSrc Source for the script tag.\n     * @param options Options to define which type of script this is.\n     */\n    setPreviewScript(scriptSrc, options) {\n        return this._instance.setPreviewScript(scriptSrc, options);\n    }\n    /**\n     * The default value of the `PATH` environment variable for processes started through {@link spawn}.\n     */\n    get path() {\n        return this._runtimeInfo.path;\n    }\n    /**\n     * The full path to the working directory (see {@link FileSystemAPI}).\n     */\n    get workdir() {\n        return this._runtimeInfo.cwd;\n    }\n    /**\n     * Destroys the WebContainer instance, turning it unusable, and releases its resources. After this,\n     * a new WebContainer instance can be obtained by calling {@link WebContainer.boot | `boot`}.\n     *\n     * All entities derived from this instance (e.g. processes, the file system, etc.) also become unusable\n     * after calling this method.\n     */\n    teardown() {\n        if (this._tornDown) {\n            throw new Error('WebContainer already torn down');\n        }\n        this._tornDown = true;\n        this._unsubscribeFromTokenChangedListener();\n        this.fs._teardown();\n        this._instance.teardown();\n        this._instance[Comlink.releaseProxy]();\n        if (WebContainer._instance === this) {\n            WebContainer._instance = null;\n        }\n    }\n    /**\n     * Boots a WebContainer. Only a single instance of WebContainer can be booted concurrently\n     * (see {@link WebContainer.teardown | `teardown`}).\n     *\n     * Booting WebContainer is an expensive operation.\n     */\n    static async boot(options = {}) {\n        const { workdirName } = options;\n        if (window.crossOriginIsolated && options.coep === 'none') {\n            console.warn(`A Cross-Origin-Embedder-Policy header is required in cross origin isolated environments.\\nSet the 'coep' option to 'require-corp'.`);\n        }\n        if (workdirName?.includes('/') || workdirName === '..' || workdirName === '.') {\n            throw new Error('workdirName should be a valid folder name');\n        }\n        // signal that boot was called to auth module as calling auth.init after boot is likely incorrect\n        authState.bootCalled = true;\n        // try to \"acquire the lock\", i.e. wait for any ongoing boot request to finish\n        while (bootPromise) {\n            await bootPromise;\n        }\n        if (WebContainer._instance) {\n            throw new Error('Only a single WebContainer instance can be booted');\n        }\n        const instancePromise = unsynchronizedBoot(options);\n        // the \"lock\" is a promise for the ongoing boot that never fails\n        bootPromise = instancePromise.catch(() => { });\n        try {\n            const instance = await instancePromise;\n            WebContainer._instance = instance;\n            return instance;\n        }\n        finally {\n            // release the \"lock\"\n            bootPromise = null;\n        }\n    }\n}\n/**\n * Configure an API key to be used for this instance of WebContainer.\n *\n * @param key WebContainer API key.\n */\nexport function configureAPIKey(key) {\n    if (authState.bootCalled) {\n        throw new Error('`configureAPIKey` should always be called before `WebContainer.boot`');\n    }\n    iframeSettings.setQueryParam('client_id', key);\n}\nconst DIR_ENTRY_TYPE_FILE = 1;\nconst DIR_ENTRY_TYPE_DIR = 2;\n/**\n * @internal\n */\nclass DirEntImpl {\n    name;\n    _type;\n    constructor(name, _type) {\n        this.name = name;\n        this._type = _type;\n    }\n    isFile() {\n        return this._type === DIR_ENTRY_TYPE_FILE;\n    }\n    isDirectory() {\n        return this._type === DIR_ENTRY_TYPE_DIR;\n    }\n}\nclass FSWatcher {\n    _apiClient;\n    _path;\n    _options;\n    _listener;\n    _wrappedListener;\n    _watcher;\n    _closed = false;\n    constructor(_apiClient, _path, _options, _listener) {\n        this._apiClient = _apiClient;\n        this._path = _path;\n        this._options = _options;\n        this._listener = _listener;\n        this._apiClient._watchers.add(this);\n        this._wrappedListener = (event, filename) => {\n            if (this._listener && !this._closed) {\n                this._listener(event, filename);\n            }\n        };\n        this._apiClient._fs\n            .watch(this._path, this._options, proxyListener(this._wrappedListener))\n            .then((_watcher) => {\n            this._watcher = _watcher;\n            if (this._closed) {\n                this._teardown();\n            }\n        })\n            .catch(console.error);\n    }\n    close() {\n        if (!this._closed) {\n            this._closed = true;\n            this._apiClient._watchers.delete(this);\n            this._teardown();\n        }\n    }\n    /**\n     * @internal\n     */\n    _teardown() {\n        this._watcher?.close().finally(() => {\n            this._watcher?.[Comlink.releaseProxy]();\n        });\n    }\n}\n/**\n * @internal\n */\nclass WebContainerProcessImpl {\n    output;\n    input;\n    exit;\n    _process;\n    stdout;\n    stderr;\n    constructor(process, output, stdout, stderr) {\n        this.output = output;\n        this._process = process;\n        this.input = new WritableStream({\n            write: (data) => {\n                // this promise is not supposed to fail anyway\n                this._getProcess()\n                    ?.write(data)\n                    .catch(() => { });\n            },\n        });\n        this.exit = this._onExit();\n        this.stdout = stdout;\n        this.stderr = stderr;\n    }\n    kill() {\n        this._getProcess()?.kill();\n    }\n    resize(dimensions) {\n        this._getProcess()?.resize(dimensions);\n    }\n    async _onExit() {\n        try {\n            return await this._process.onExit;\n        }\n        finally {\n            this._process?.[Comlink.releaseProxy]();\n            this._process = null;\n        }\n    }\n    _getProcess() {\n        if (this._process == null) {\n            console.warn('This process already exited');\n        }\n        return this._process;\n    }\n}\n/**\n * @internal\n */\nclass FileSystemAPIClient {\n    _fs;\n    _watchers = new Set([]);\n    constructor(fs) {\n        this._fs = fs;\n    }\n    rm(...args) {\n        return this._fs.rm(...args);\n    }\n    async readFile(path, encoding) {\n        return await this._fs.readFile(path, encoding);\n    }\n    async rename(oldPath, newPath) {\n        return await this._fs.rename(oldPath, newPath);\n    }\n    async writeFile(path, data, options) {\n        if (data instanceof Uint8Array) {\n            const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n            data = Comlink.transfer(new Uint8Array(buffer), [buffer]);\n        }\n        await this._fs.writeFile(path, data, options);\n    }\n    async readdir(path, options) {\n        const result = await this._fs.readdir(path, options);\n        if (isStringArray(result)) {\n            return result;\n        }\n        if (isTypedArrayCollection(result)) {\n            return result;\n        }\n        const entries = result.map((entry) => new DirEntImpl(entry.name, entry['Symbol(type)']));\n        return entries;\n    }\n    async mkdir(path, options) {\n        return await this._fs.mkdir(path, options);\n    }\n    watch(path, options, listener) {\n        if (typeof options === 'function') {\n            listener = options;\n            options = null;\n        }\n        return new FSWatcher(this, path, options, listener);\n    }\n    /**\n     * @internal\n     */\n    _teardown() {\n        this._fs[Comlink.releaseProxy]();\n        for (const watcherWrapper of this._watchers) {\n            watcherWrapper.close();\n        }\n    }\n}\nasync function unsynchronizedBoot(options) {\n    const { serverPromise } = serverFactory(options);\n    const server = await serverPromise;\n    const instance = await server.build({\n        host: window.location.host,\n        version: \"1.5.3\",\n        workdirName: options.workdirName,\n        forwardPreviewErrors: options.forwardPreviewErrors,\n    });\n    const [fs, previewScript, runtimeInfo] = await Promise.all([\n        instance.fs(),\n        instance.previewScript(),\n        instance.runtimeInfo(),\n    ]);\n    return new WebContainer(instance, fs, previewScript, runtimeInfo);\n}\nfunction binaryListener(listener) {\n    if (listener == null) {\n        return undefined;\n    }\n    return (data) => {\n        if (data instanceof Uint8Array) {\n            listener(decoder.decode(data));\n        }\n        else if (data == null) {\n            listener(null);\n        }\n    };\n}\nfunction proxyListener(listener) {\n    if (listener == null) {\n        return undefined;\n    }\n    return Comlink.proxy(listener);\n}\nfunction serverFactory(options) {\n    if (cachedServerPromise != null) {\n        if (options.coep !== cachedBootOptions.coep) {\n            console.warn(`Attempting to boot WebContainer with 'coep: ${options.coep}'`);\n            console.warn(`First boot had 'coep: ${cachedBootOptions.coep}', new settings will not take effect!`);\n        }\n        return { serverPromise: cachedServerPromise };\n    }\n    if (options.coep) {\n        iframeSettings.setQueryParam('coep', options.coep);\n    }\n    if (options.experimentalNode) {\n        iframeSettings.setQueryParam('experimental_node', '1');\n    }\n    const iframe = document.createElement('iframe');\n    iframe.style.display = 'none';\n    iframe.setAttribute('allow', 'cross-origin-isolated');\n    const url = iframeSettings.url;\n    iframe.src = url.toString();\n    const { origin } = url;\n    cachedBootOptions = { ...options };\n    cachedServerPromise = new Promise((resolve) => {\n        const onMessage = (event) => {\n            if (event.origin !== origin) {\n                return;\n            }\n            const { data } = event;\n            if (data.type === 'init') {\n                resolve(Comlink.wrap(event.ports[0]));\n                return;\n            }\n            if (data.type === 'warning') {\n                console[data.level].call(console, data.message);\n                return;\n            }\n        };\n        window.addEventListener('message', onMessage);\n    });\n    document.body.insertBefore(iframe, null);\n    return { serverPromise: cachedServerPromise };\n}\nfunction isStringArray(list) {\n    return typeof list[0] === 'string';\n}\nfunction isTypedArrayCollection(list) {\n    return list[0] instanceof Uint8Array;\n}\nfunction streamWithPush() {\n    let controller = null;\n    const stream = new ReadableStream({\n        start(controller_) {\n            controller = controller_;\n        },\n    });\n    const push = (item) => {\n        if (item != null) {\n            controller?.enqueue(item);\n        }\n        else {\n            controller?.close();\n            controller = null;\n        }\n    };\n    return { stream, push };\n}\nfunction syncSubscription(listener) {\n    let stopped = false;\n    let unsubscribe = () => { };\n    const wrapped = ((...args) => {\n        if (stopped) {\n            return;\n        }\n        listener(...args);\n    });\n    return {\n        subscribe(promise) {\n            promise.then((unsubscribe_) => {\n                unsubscribe = unsubscribe_;\n                if (stopped) {\n                    unsubscribe();\n                }\n            });\n            return () => {\n                stopped = true;\n                unsubscribe();\n            };\n        },\n        listener: wrapped,\n    };\n}\n", "import { smartartPlugin } from \"./smartart-plugin.js\";\nimport { WebContainer } from \"@webcontainer/api\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  // DOM elements\n  const inputArea = document.getElementById(\"input-area\");\n  const outputArea = document.getElementById(\"output-area\");\n  const renderBtn = document.getElementById(\"render-btn\");\n  const clearBtn = document.getElementById(\"clear-btn\");\n  const webcOutputFrame = document.getElementById('webc-output-frame');\n\n  // Event listeners\n  clearBtn.addEventListener(\"click\", () => {\n    inputArea.value = \"\";\n    outputArea.innerHTML = \"\";\n    webcOutputFrame.srcdoc = \"\";\n  });\n\n  // Render PPT using WebContainers Marp CLI with custom SmartArt plugins\n  if (renderBtn && webcOutputFrame) {\n    renderBtn.addEventListener('click', async () => {\n      try {\n        const markdown = inputArea.value;\n        webcOutputFrame.srcdoc = \"<p><em>Rendering slides...</em></p>\";\n        \n        // 1. Boot WebContainer and prepare files\n        const webcontainerInstance = await WebContainer.boot();\n        \n        // Write markdown and package.json\n        await Promise.all([\n          webcontainerInstance.fs.writeFile('/presentation.md', markdown),\n          webcontainerInstance.fs.writeFile('/package.json', JSON.stringify({\n            name: \"marp-smartart\",\n            type: \"module\",\n            dependencies: { \n              \"@marp-team/marp-cli\": \"^4.1.2\",\n              \"@marp-team/marp-core\": \"^3.8.0\"\n            }\n          }, null, 2))\n        ]);\n        \n        // 2. Set up plugins\n        await webcontainerInstance.fs.mkdir('/plugins');\n        \n        // Fetch and write all plugin files in parallel\n        const pluginFiles = ['utils.js', 'pyramid.js', 'venn.js', 'chevron.js', 'smartart-plugin.js'];\n        await Promise.all(\n          pluginFiles.map(async file => {\n            // When bundled, we need to use the right path\n            const isProduction = window.location.pathname.includes('/dist/');\n            const basePath = isProduction ? './' : './';\n            const content = await fetch(`${basePath}${file}`).then(res => res.text());\n            return webcontainerInstance.fs.writeFile(`/plugins/${file}`, content);\n          })\n        );\n        \n        // Write the engine file\n        await webcontainerInstance.fs.writeFile('/marp-engine.js', `\nimport { Marp } from '@marp-team/marp-core';\nimport { smartartPlugin } from './plugins/smartart-plugin.js';\n\nexport default ({ marp }) => {\n  smartartPlugin(marp);\n  return marp;\n};`);\n        \n        // 3. Install dependencies and run Marp CLI\n        const installProcess = await webcontainerInstance.spawn('npm', ['install']);\n        await installProcess.exit;\n        \n        const marpProcess = await webcontainerInstance.spawn('npx', [\n          'marp', 'presentation.md', '--html', '--engine', './marp-engine.js', '-o', 'output.html'\n        ]);\n        await marpProcess.exit;\n        \n        // 4. Display output\n        webcOutputFrame.srcdoc = await webcontainerInstance.fs.readFile('/output.html', 'utf8');\n      } catch (error) {\n        console.error(\"Error rendering slides:\", error);\n        webcOutputFrame.srcdoc = `<div style=\"color:red;padding:20px;\">Error: ${error.message}</div>`;\n      }\n    });\n  }\n});\n"],
  "mappings": "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",
  "names": ["DEFAULT_EDITOR_ORIGIN", "TypedEventTarget", "__publicField", "listener", "wrappedListener", "event", "data", "IGNORED_ERROR", "accessTokenChangedListeners", "TypedEventTarget", "addAccessTokenChangedListener", "listener", "accessTokenChangedListeners", "params", "editorOrigin", "iframeSettings", "DEFAULT_EDITOR_ORIGIN", "newOrigin", "key", "value", "url", "param", "resettablePromise", "resolve", "promise", "reset", "_resolve", "value", "authState", "resettablePromise", "iframeSettings", "authFailedListeners", "TypedEventTarget", "loggedOutListeners", "assertAuthTokens", "tokens", "PreviewMessageType", "__defProp", "__export", "target", "all", "name", "comlink_exports", "createEndpoint", "expose", "proxy", "proxyMarker", "releaseProxy", "transfer", "transferHandlers", "windowEndpoint", "wrap", "throwMarker", "isObject", "val", "proxyTransferHandler", "obj", "port1", "port2", "port", "throwTransferHandler", "value", "serialized", "ep", "callback", "ev", "id", "type", "path", "argumentList", "fromWireValue", "returnValue", "parent", "obj2", "prop", "rawValue", "returnValue2", "wireValue", "transferables", "toWireValue", "closeEndPoint", "isMessagePort", "endpoint", "createProxy", "throwIfProxyReleased", "isReleased", "isProxyReleased", "proxy2", "_target", "requestResponseMessage", "p", "r", "_thisArg", "rawArgumentList", "last", "processArguments", "myFlat", "arr", "processed", "v", "transferCache", "transfers", "w", "context", "targetOrigin", "msg", "handler", "serializedValue", "resolve", "generateUUID", "l", "PREVIEW_MESSAGE_TYPES", "PreviewMessageType", "isPreviewMessage", "data", "nullPrototype", "source", "prototype", "binaryDecoder", "toInternalFileSystemTree", "tree", "newTree", "name", "entry", "contents", "stringContents", "binary", "newEntry", "toExternalFileSystemTree", "nullPrototype", "fromBinaryString", "s", "encoded", "i", "bootPromise", "cachedServerPromise", "cachedBootOptions", "decoder", "encoder", "_WebContainer", "_instance", "fs", "previewScript", "_runtimeInfo", "__publicField", "FileSystemAPIClient", "authState", "addAccessTokenChangedListener", "accessToken", "assertAuthTokens", "error", "command", "optionsOrArgs", "options", "args", "output", "outputStream", "result", "streamWithPush", "stdout", "stdoutStream", "stderr", "stderrStream", "wrappedOutput", "proxyListener", "binaryListener", "wrappedStdout", "wrappedStderr", "process", "WebContainerProcessImpl", "path", "serializeOptions", "data", "toExternalFileSystemTree", "event", "listener", "originalListener", "message", "isPreviewMessage", "wrapped", "subscribe", "syncSubscription", "comlink_exports", "snapshotOrTree", "payload", "toInternalFileSystemTree", "scriptSrc", "workdirName", "instancePromise", "unsynchronizedBoot", "instance", "WebContainer", "DIR_ENTRY_TYPE_FILE", "DIR_ENTRY_TYPE_DIR", "DirEntImpl", "name", "_type", "__publicField", "FSWatcher", "_apiClient", "_path", "_options", "_listener", "event", "filename", "proxyListener", "_watcher", "comlink_exports", "WebContainerProcessImpl", "process", "output", "stdout", "stderr", "data", "dimensions", "FileSystemAPIClient", "fs", "args", "path", "encoding", "oldPath", "newPath", "options", "buffer", "result", "isStringArray", "isTypedArrayCollection", "entry", "listener", "watcherWrapper", "unsynchronizedBoot", "serverPromise", "serverFactory", "instance", "previewScript", "runtimeInfo", "WebContainer", "binaryListener", "decoder", "cachedServerPromise", "cachedBootOptions", "iframeSettings", "iframe", "url", "origin", "resolve", "onMessage", "list", "streamWithPush", "controller", "controller_", "item", "syncSubscription", "stopped", "unsubscribe", "promise", "unsubscribe_", "inputArea", "outputArea", "renderBtn", "clearBtn", "webcOutputFrame", "markdown", "webcontainerInstance", "WebContainer", "pluginFiles", "file", "isProduction", "content", "res", "error"]
}
